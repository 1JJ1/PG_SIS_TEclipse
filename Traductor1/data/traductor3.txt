STM = statement: <statement>
name_stm = <labeled-statement>
null_stm = <labeled-statement>
assign = <assignment-expression>
procedure_call = <expression-statement>
exit = <jump-statement>
return = <jump-statement>
goto = <jump-statement>
entry_call = <jump-statement>
delay = <>
abort = <>
raise = <>
code = <compound-statement>
if = <selection-statement>
case = <selection-statement>
LOOP = <iteration-statement>
block = <iteration-statement>
accept = <>
select = <selection-statement>
cond_entry = <conditional-expression>
var = variable: <primary-expression> <constant>
as_id_s = <typedef-name>
as_name = <type-name>
as_variant_s = <primary-expression>
as_object = <primary-expression>
as_choice = <primary-expression>
var_id = <typedef-name>
variant = <typedef-name>
variant_part = <type-name>
variant_s = <primary-expression>
tx_comments = <comments>
EXP = <struct-declarator>
EXP_CONSTRAINED = <external-declaration>
EXP_VOID = <struct-declarator>
numeric_literal = <integer-constant>
aggregate = <struct-declarator-list>
allocator = <specifier-qualifier>
conversion = <specifier-qualifier>
qualified = <type-qualifier>
exp_s = <struct-declarator>
string_literal = <string>
enum_literal_s = <enumeration-list>
TYPE_SPEC = type_specification: <type-specifier> <enum-specifier>
integer = <integer-constant>
array = <struct-declarator-list>
record = <storage-class-specifier>
access = <>
derived = <>
task_spec = <storage-class-specifier>
fixed = <>
float = <floating-constant>
function = function: <function-definition>
function_call = <declaration-specifier>
as_param_s = <parameter-declaration>
as_name_void = <declaration-specifier>
param_s = <parameter-list>
as_param_assoc = <parameter-type-list>
DESIGNATOR = <direct-declarator>
DESIGNATOR_CHAR = <character-constant>
DEF_ID = <identifier>
DEF_OCCURRENCE = <identifier>
entry_id = <declarator>
task_body_id = <typedef-name>
proc_id = <typedef-name>
named_stm_id = <type-name>
pragma = <pragma>
pragma_id = <typedef-name> 
pragma_s = <external-declaration>
